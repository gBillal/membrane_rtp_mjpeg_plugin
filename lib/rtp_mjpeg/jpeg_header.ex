defmodule Membrane.RTP.MJPEG.JpegHeader do
  @moduledoc """
  Module responsible for parsing and reconstructing JPEG header from RTP packets.
  """

  import Bitwise

  @lum_dc_codelens [0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]
  @lum_dc_symbols [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  @lum_ac_codelens [0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7D]
  @lum_ac_symbols [
                    [0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12],
                    [0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07],
                    [0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08],
                    [0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0],
                    [0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16],
                    [0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28],
                    [0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39],
                    [0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49],
                    [0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59],
                    [0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69],
                    [0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79],
                    [0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89],
                    [0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98],
                    [0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7],
                    [0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6],
                    [0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5],
                    [0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4],
                    [0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2],
                    [0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA],
                    [0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8],
                    [0xF9, 0xFA]
                  ]
                  |> List.flatten()

  @chm_dc_codelens [0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
  @chm_dc_symbols [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  @chm_ac_codelens [0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77]
  @chm_ac_symbols [
                    [0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21],
                    [0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71],
                    [0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91],
                    [0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0],
                    [0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34],
                    [0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26],
                    [0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38],
                    [0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48],
                    [0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58],
                    [0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68],
                    [0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78],
                    [0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87],
                    [0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96],
                    [0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5],
                    [0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4],
                    [0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3],
                    [0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2],
                    [0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA],
                    [0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9],
                    [0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8],
                    [0xF9, 0xFA]
                  ]
                  |> List.flatten()

  @type t :: %__MODULE__{
          type_specific: integer(),
          fragment_offset: integer(),
          type: integer(),
          q: integer(),
          width: integer(),
          height: integer(),
          pixel_format: :I420 | :I422
        }

  defstruct [:type_specific, :fragment_offset, :type, :q, :width, :height, :pixel_format]

  @doc """
  Parse JPEG header from RTP payload.
  """
  @spec parse(binary()) :: {:ok, {t(), binary()}} | {:error, :invalid_header}
  def parse(
        <<type_specific::8, fragment_offset::24, type::8, q::8, width::8, height::8,
          rest::binary>>
      )
      when type == 0 or type == 1 do
    jpeg_header =
      %__MODULE__{
        type_specific: type_specific,
        fragment_offset: fragment_offset,
        type: type,
        q: q,
        width: width * 8,
        height: height * 8,
        pixel_format: pixel_format(type)
      }

    {:ok, {jpeg_header, rest}}
  end

  def parse(_payload), do: {:error, :invalid_header}

  @doc """
  Make JPEG headers to append to the payload to make a valid JPEG.
  """
  @spec make_headers(t(), [integer()], [integer()]) :: iodata()
  def make_headers(%{type: type, width: w, height: h}, lqt, cqt) do
    type = if type == 0, do: 0x21, else: 0x22

    [
      0xFF,
      0xD8,
      make_quant_header(lqt, 0),
      make_quant_header(cqt, 1),
      [0xFF, 0xC0, 0, 17, 8],
      [h >>> 8, h &&& 0xFF, w >>> 8, w &&& 0xFF, 3, 0, type, 0, 1, 0x11, 1, 2, 0x11, 1],
      make_huffman_header(@lum_dc_codelens, @lum_dc_symbols, 0, 0),
      make_huffman_header(@lum_ac_codelens, @lum_ac_symbols, 0, 1),
      make_huffman_header(@chm_dc_codelens, @chm_dc_symbols, 1, 0),
      make_huffman_header(@chm_ac_codelens, @chm_ac_symbols, 1, 1),
      [0xFF, 0xDA, 0, 12, 3, 0, 0, 1, 0x11, 2, 0x11, 0, 63, 0]
    ]
  end

  defp pixel_format(0), do: :I422
  defp pixel_format(1), do: :I420

  defp make_quant_header(qt, table_no), do: [0xFF, 0xDB, 0, 67, table_no, qt]

  defp make_huffman_header(codelens, symbols, table_no, table_class) do
    [
      0xFF,
      0xC4,
      0,
      3 + length(codelens) + length(symbols),
      table_class <<< 4 ||| table_no,
      codelens,
      symbols
    ]
  end
end
